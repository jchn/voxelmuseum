var inherits = require('inherits')
var EventEmitter = require('events').EventEmitter

module.exports = function( game, opts ) {
	return new Builder( game, opts )
}

module.exports.Builder = Builder
//TODO instead of using setTimeout, use the gameloop
function Builder( game, opts ) {

	if (!(this instanceof Builder)) return new Builder( game, opts );

	this.game = game;
	this.opts = opts || {};
	this.height = this.opts.height || 2;
	this.material = this.opts.material || 'brick';
	this.T = game.THREE;
	this.checkItems = [];

	var _this = this;

	var t = 0;
	/*
	this.game.on('tick', function(delta) {
		var i = _this.game.items.length;
		while ( i-- ) {
			var item = _this.game.items[i];
			if( item.extra && typeof(item.extra.isPosReached) === 'function' && item.extra.isPosReached() ) {

				_this.game.removeItem( item );
				_this.game.setBlock( item.extra.finalPos.toArray(), _this.game.materials.findIndex(item.extra.texture) );

			};
		};
		
	});
	*/

}

inherits(Builder, EventEmitter);

Builder.prototype.placeObject = function( building, position ) {

	var pos = !(position == undefined ) ? position : new this.T.Vector3(0, 0, 0),
	structure = this._processStructureData( building, position ),
	structure = this._setPosition( structure, pos ),
	structureLength = structure.length,
	_this = this,
	i = 0;

	while( structureLength-- ) {

		var currStructure = structure[structureLength];

		this.game.setBlock( currStructure.pos.toArray(), currStructure.t );
	}

	return structure;

};

Builder.prototype.placeObjectIntervalled = function( building, intDuration, position ) {

	var pos = !(position == undefined ) ? position : new this.T.Vector3(0, 0, 0),
	structure = this._processStructureData( building ),
	structure = this._setPosition( structure, pos ),
	structureLength = structure.length,
	_this = this,
	i = 0,
	interval = intDuration;

	var _structure = this.sortElements( structure );

	(function iterator() {
		var currStructure = _structure[i];

		_this.game.setBlock( currStructure.pos.toArray(), currStructure.t );

	    if(++i<structureLength) setTimeout(iterator, intDuration);
	    else _this.emit('complete', _structure);
	})();

	return _structure;

}

Builder.prototype.placeObjectFalling = function( building, intDuration, position ) {
	//var _position = new this.T.Vector3(10, 2, 0);
	var pos = !(position == undefined ) ? position : new this.T.Vector3(0, 0, 0),
	structure = this._processStructureData( building ),
	structure = this._setPosition( structure, pos ),
	structureLength = structure.length,
	_this = this,
	i = 0,
	interval = intDuration;

	var _structure = this.sortElements( structure );

	(function iterator() {
		var currStructure = _structure[i];

		// get a previously loaded texture by name
		//var material = _this.game.materials.find(currStructure.t);
		//var material = _this.game.materials.find('grass');
		console.log('material');
		//console.log(material);
		console.log(_this.game.materials);

		// create a mesh and set the matertial
		var mesh = new _this.game.THREE.Mesh(
		  new _this.game.THREE.CubeGeometry(_this.game.cubeSize, _this.game.cubeSize, _this.game.cubeSize), // width, height, depth
		  new _this.game.THREE.MeshFaceMaterial(material)
		);

		// move item to some location, add an offset of 0.5 so the blocks will align (pivot point of items isn't centered)
		mesh.translateX(currStructure.pos.x + (_this.game.cubeSize * 0.5))
		mesh.translateY(12)
		mesh.translateZ(currStructure.pos.z + (_this.game.cubeSize * 0.5))

		var item = {
		  mesh: mesh,
		  width: _this.game.cubeSize,
		  height: _this.game.cubeSize,
		  depth: _this.game.cubeSize,
		  collisionRadius: 10,
		  velocity: { x: 0, y: 0.02, z: 0 },
		  size: _this.game.cubeSize,
		  extra: {
		  	mesh: mesh,
			  finalPos: currStructure.pos,
			  texture: currStructure.t,
			  isPosReached : function() {
			  	return (this.mesh.position.y <= this.finalPos.y);
				}
		  }
		}
		
		_this.game.addItem( item );

	   if(++i<structureLength) setTimeout(iterator, intDuration);
	   else _this.emit('complete', _structure);
	})();

	return _structure;

}

Builder.prototype.placeObjectWave = function( building, intDuration, position ) {
	//var _position = new this.T.Vector3(10, 2, 0);
	var pos = !(position == undefined ) ? position : new this.T.Vector3(0, 0, 0),
	structure = this._processStructureData( building ),
	structure = this._setPosition( structure, pos ),
	structureLength = structure.length,
	_this = this,
	i = 0,
	interval = intDuration;

	var _structure = this.sortElementsBeams( structure );
	structureLength = _structure.length;
	var map = this.sortElements( structure );

	(function iterator() {
		var currStructure = _structure[i],
		currStructureLength = currStructure.length;

		while(currStructureLength--) {
			var currBlock = currStructure[currStructureLength];
			_this.game.setBlock( currBlock.pos.toArray(), currBlock.t );
		}

	   if(++i<structureLength) {
			setTimeout(iterator, intDuration);
			//setTimeout( it2, intDuration )
		} else {
			_this.emit('complete', _structure);
		}
	})();


	return map;

}

Builder.prototype._processStructureData = function( structureData, position ) {
	var datas = structureData.length;
	var data = [];

	// Convert json data to voxel data
	while( datas-- ) {
		var currData = structureData[datas];
		var vec3 = new this.T.Vector3( currData.x, currData.y, currData.z );

		vec3.multiplyScalar( this.game.cubeSize );

		var info = { pos : vec3, t : currData.t };

		data.push( info );
	}

	return data;
}

Builder.prototype.sortElements = function( processedData ) {
	// TODO: Sort the array of structure elements in a certain way
	// TODO: it may be faster to do the sorting before the processing
	var data = processedData;
	data.sort(function(a, b){
		if( a.pos.y < b.pos.y ) return -1;
		else if( a.pos.y > b.pos.y ) return 1;

		if( a.pos.x < b.pos.x ) return -1;
		else if( a.pos.x > b.pos.x ) return 1;

		if( a.pos.z < b.pos.z ) return -1;
		else if( a.pos.z > b.pos.z ) return 1;

		return 0;
	});

	return data;
}

Builder.prototype.sortElementsBeams = function( proccessedData ) {

	var data = proccessedData;
	data.sort(function(a, b){

		if( a.pos.z < b.pos.z ) return -1;
		else if( a.pos.z > b.pos.z ) return 1;

		if( a.pos.y < b.pos.y ) return -1;
		else if( a.pos.y > b.pos.y ) return 1;

		if( a.pos.x > b.pos.x ) return -1;
		else if( a.pos.x < b.pos.x ) return 1;

		return 0;

	});

	var x = null,
	y = null,
	z = null,
	newData = [],
	dataLength = data.length,
	offset = 0;
	for (var i = 0; i < dataLength; i++) {
		var currentData = data[i];

		if( currentData.pos.x !== x && currentData.pos.y !== y ) {
			//New segment
			var slice = data.slice( i, i + offset );
			if(slice.length) newData.push( slice );
			offset = 0;
		}
		offset++;
		x = currentData.pos.x;
		y = currentData.pos.y;
	};

	data = newData;

	return data;

}

Builder.prototype.setMaterials = function( materialEngine ) {
	this.materials = materialEngine;
}

Builder.prototype.resetMaterials = function() {
	this.materials = this.game.materials;
}

Builder.prototype._setPosition = function( structure, position ) {

	//Assumes building blocks are sorted

	var structureLength = structure.length;
	var center = new this.T.Vector3();
	var offset = center.sub( position );

	while( structureLength-- ) {

		var currentBlock = structure[structureLength];
		currentBlock.pos = currentBlock.pos.sub( offset );

	}

	return structure;

}
