var inherits = require('inherits');
var EventEmitter = require('events').EventEmitter;

module.exports = function( game, builder, url, opts ) {
	return new Road( game, builder, url, opts );
};

module.exports.Road = Road;
//TODO instead of using setTimeout, use the gameloop
function Road( game, builder, url, opts ) {

	if (!(this instanceof Road)) return new Road( game, builder, url, opts );

	var _this = this;

	this.game = game;
	this.opts = opts || {};
	this.T = game.THREE;
	this.builder = builder;
	this.structure = require('./assets/road_expo.json');
	this.connectionPoints = this.getConnectionPoints();
	this.paintingPoints = this._getVoxelsByType( 'painting_position' );
	this.updatables = [];
	this.url = url;
	this.connectMe = [];
	this.complete = false;
	this.map = null;

	//this.connect( this.connectionPoints );

	this.game.on('tick', function(dt){
		for( var index in _this.updatables ) {
			var item = _this.updatables[index];
			item.mesh.position.y += 0.1;
			if(item.extra.isPosReached()) {
				_this.game.setBlock( item.extra.finalPos.toArray(), item.extra.t );
				for( var i in _this.game.items ) {
					var listItem = _this.game.items[i];
					if( listItem.extra !== undefined ) {
						if(listItem.extra.id === item.extra.id) {
							_this.game.removeItem( listItem );
							var indexOf = _this.updatables.indexOf( item );
							_this.updatables.splice( indexOf, 1 );

							//if(!_this.updatables.length)
								//_this.emit('complete');
						}
					}
				}
			}
		}
	});

	this.game.THREE.Vector3.prototype.toArray = function() {
		return [ this.x, this.y, this.z ];
	};

	this.on('complete', function(structure){
		_this.placePainting(structure);
		_this.complete = true;
	});

}

inherits(Road, EventEmitter);

Road.prototype.connect = function( points ) {

	console.log('connect');


	var	axis = null,
		diff = new this.T.Vector3(0, 0, 0);

	var point1 = points[0];
	var point2 = points[1];

	if( point1.x === point2.x )
		axis = 'x';
	else if( point1.z === point2.z )
		axis = 'z';
	else return;

	// For now we only need to check 1 point
	console.log('diff');
	diff.sub( point1, this.connectionPoints[0][0] );

	this.map = this.place( this.structure, 200, diff );

};

Road.prototype.placePainting = function( structure ) {

	var _this = this,
	url = this.url;

	var img = new this.T.MeshBasicMaterial({
		map:_this.T.ImageUtils.loadTexture(url)
	});

	// plane

	var plane = new this.T.Mesh(new _this.T.PlaneGeometry(5, 5),img);
	this.paintingPoints = this._getBlocksByType(structure, 'painting_position');//new this.T.Vector3(this.paintingPoints[0].x, this.paintingPoints[0].y, this.paintingPoints[0].z);

	plane.position = this.paintingPoints[1].pos;
	plane.position.y = 3;
	plane.rotation.y = 1.5;
	plane.overdraw = true;
	this.game.scene.add(plane);
	window.plane = plane;

};

Road.prototype._processStructureData = function( structureData ) {
	console.log('_processStructureData');
	var datas = structureData.length;
	var data = [];

	// Convert json data to voxel data
	while( datas-- ) {
		var currData = structureData[datas];
		var vec3 = new this.T.Vector3( currData.x, currData.y, currData.z );

		vec3.multiplyScalar( this.game.cubeSize );

		var info = { pos : vec3, t : currData.t };

		data.push( info );
	}

	return data;
};

Road.prototype.sortElements = function( processedData, direction ) {

	var data = processedData;
	var sort = function(a, b){ return 0; };
	//TODO: sort this stuff out better, considering all the sorting options
	switch( direction ) {
		case 1:

			sort = function(a, b) {
				if( a.pos.y < b.pos.y ) return -1;
				else if( a.pos.y > b.pos.y ) return 1;

				if( a.pos.x < b.pos.x ) return -1;
				else if( a.pos.x > b.pos.x ) return 1;

				if( a.pos.z < b.pos.z ) return -1;
				else if( a.pos.z > b.pos.z ) return 1;

				return 0;
			};

		break;
		case 2:

			sort = function(a, b) {
				if( a.pos.y < b.pos.y ) return -1;
				else if( a.pos.y > b.pos.y ) return 1;

				if( a.pos.x > b.pos.x ) return -1;
				else if( a.pos.x < b.pos.x ) return 1;

				if( a.pos.z < b.pos.z ) return -1;
				else if( a.pos.z > b.pos.z ) return 1;

				return 0;
			};

		break;
		case 3:

			sort = function(a, b) {
				if( a.pos.y < b.pos.y ) return -1;
				else if( a.pos.y > b.pos.y ) return 1;

				if( a.pos.z < b.pos.z ) return -1;
				else if( a.pos.z > b.pos.z ) return 1;

				if( a.pos.x > b.pos.x ) return -1;
				else if( a.pos.x < b.pos.x ) return 1;

				return 0;
			};

		break;
		case 4:

			sort = function(a, b) {
				if( a.pos.y < b.pos.y ) return -1;
				else if( a.pos.y > b.pos.y ) return 1;

				if( a.pos.z > b.pos.z ) return -1;
				else if( a.pos.z < b.pos.z ) return 1;

				if( a.pos.x > b.pos.x ) return -1;
				else if( a.pos.x < b.pos.x ) return 1;

				return 0;
			};

		break;
		case 5:

			sort = function(a, b) {

				if( a.pos.z < b.pos.z ) return -1;
				else if( a.pos.z > b.pos.z ) return 1;

				if( a.pos.x > b.pos.x ) return -1;
				else if( a.pos.x < b.pos.x ) return 1;

				if( a.pos.y < b.pos.y ) return -1;
				else if( a.pos.y > b.pos.y ) return 1;

				return 0;
			};

		break;
	}

	data.sort(sort);

	return data;
};

Road.prototype.placeObjectIntervalled = function( building, intDuration, position ) {

	var pos = !(position == undefined ) ? position : new this.T.Vector3(0, 0, 0),
	structure = this._processStructureData( building ),
	structure = this._setPosition( structure, pos ),
	structureLength = structure.length,
	_this = this,
	i = 0,
	interval = intDuration;

	var _structure = this.sortElements( structure, 5 );

	(function iterator() {
		var currStructure = _structure[i];

		_this.game.setBlock( currStructure.pos.toArray(), currStructure.t );

		if(++i<structureLength) setTimeout(iterator, intDuration);
		else _this.emit('complete', _structure);
	})();

	return _structure;

};

Road.prototype.getRoadChunks = function( pos, structure, direction ) {
	console.log('getRoadChunks');
	// TODO: Now only works for direction 5

	var	structureLength = structure.length,
		_this = this,
		output = [],
		tempArray = [],
		prevZ = null;

	var _structure = this.sortElements( structure, 5 );

	for( var index in _structure ) {
		var block = _structure[index],
			currZ = block.pos.z;

		if( currZ === prevZ || prevZ === null) {
			tempArray.push( block );
		} else {
			output.push( tempArray );
			tempArray = [];
		}

		prevZ = currZ;

	}

	return output;

};

Road.prototype.place = function( building, intDuration, position ) {

	var pos = !(position == undefined ) ? position : new this.T.Vector3(0, 0, 0),
	structure = this._processStructureData( building ),
	structure = this._setPosition( structure, pos ),
	structureLength = structure.length,
	_this = this,
	i = 0,
	interval = intDuration,
	id = 0;

	var _structure = this.sortElements( structure, 5 ),
	chunks = this.getRoadChunks( pos, structure, 5 ),
	chunksLength = chunks.length;

	(function iterator() {

		var currChunk = chunks[i];
		for( var index in currChunk ) {
			var block = currChunk[index];

			var pos = block.pos.clone();

			var item = _this.makeItem( pos, /*block.t*/ 'grass' );
			item['extra'] = {
				mesh : item.mesh,
				finalPos : block.pos,
				t : block.t,
				isPosReached : function() {
					if( this.mesh.position.y > this.finalPos.y + 0.5 ) return true;
					return false;
				},
				id : id++
			};

			_this.game.addItem( item );

			_this.updatables.push( item );

			//_this.game.setBlock( block.pos.toArray(), block.t );
		}

		if(++i<chunksLength) setTimeout(iterator, intDuration);
		else _this.emit('complete', _structure);
	})();

	return _structure;

};

Road.prototype.makeItem = function( position, material ) {

	// create a mesh and set the matertial of the texture atlas
	var mesh = new this.T.Mesh(
		new this.T.CubeGeometry(this.game.cubeSize, this.game.cubeSize, this.game.cubeSize), // width, height, depth
		this.game.materials.material
	);

	// paint the mesh with a previously loaded texture
	this.game.materials.paint(mesh, material);

	// move item to some location
	mesh.translateX(position.x + 0.5);
	mesh.translateY(position.y - 5);
	mesh.translateZ(position.z + 0.5);

	// if these item dimensions don't match the mesh's dimensions,
	// the object's physics will not operate correctly.
	var item = {
		mesh: mesh,
		width: this.game.cubeSize,
		height: this.game.cubeSize,
		depth: this.game.cubeSize,
		collisionRadius: 20, // padding around object dimensions box for collisions
		velocity: { x: 0, y: 0, z: 0 }, // initial velocity
		extra : null,
		tick : function() {}
	};

	return item;

};

Road.prototype._setPosition = function( structure, position ) {

	//Assumes building blocks are sorted

	var structureLength = structure.length;
	var center = new this.T.Vector3();
	var offset = center.sub( position );

	while( structureLength-- ) {

		var currentBlock = structure[structureLength];
		currentBlock.pos = currentBlock.pos.sub( offset );

	}

	return structure;

};

Road.prototype.getConnectionPoints = function() {
	var _this = this;
	return function() {
		var blocks = _this._getVoxelsByType('endpoint'),
		vectors = [];

		for(var index in blocks) {
			var block = blocks[index];
			vectors.push( new _this.T.Vector3( block.x, block.y, block.z ) );
		}
		vectors.sort(function(a, b) {
			if( a.z === b.z ) return 0;
			else return 1;
		});

		return [ [ vectors[0], vectors[1] ], [ vectors[2], vectors[3] ] ];
	}();
};

Road.prototype.getLiveConnectionPoints = function() {
	var _this = this;
	console.log(_this.map);
	return function() {
		var blocks = _this._getBlocksByType(_this.map, 'endpoint'),
		vectors = [];

		for(var index in blocks) {
			var block = blocks[index];
			vectors.push( new _this.T.Vector3( block.pos.x, block.pos.y, block.pos.z ) );
		}
		vectors.sort(function(a, b) {
			if( a.z === b.z ) return 0;
			else return 1;
		});

		return [ [ vectors[0], vectors[1] ], [ vectors[2], vectors[3] ] ];
	}();
};

Road.prototype._getVoxelsByType = function(type) {

	var blocks = [],
	totalBlocksLength = this.structure.length;

	while(totalBlocksLength--) {
		var currentBlock = this.structure[totalBlocksLength];
		if( currentBlock.t === type ) {
			blocks.push(currentBlock);
		}
	}
	return blocks;
};

Road.prototype._getBlocksByType = function(blocks, type) {
// TODO: merge with previous method
	totalBlocksLength = blocks.length;
	var output = [];
	while(totalBlocksLength--) {
		var currentBlock = blocks[totalBlocksLength];
		if( currentBlock.t === type ) {
			output.push(currentBlock);
		}
	}
	return output;
};
